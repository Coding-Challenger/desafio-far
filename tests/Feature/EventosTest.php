<?php

namespace Tests\Feature;

use App\Models\Eventos;
use App\Models\TipoEvento;
use App\Models\User;
use Carbon\Carbon;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Facades\DB;
use Tests\TestCase;

class EventosTest extends TestCase
{

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->withoutExceptionHandling();
    }

    /**
     * A basic feature test example.
     */
    public function test_should_return_a_collection(): void
    {
        $response = $this->actingAs($this->currentUser())->get('/api/eventos');

        $response->assertJsonIsArray();
        $response->assertStatus(200);
    }

    public function currentUser()
    {
        return User::first();
    }

    public function test_can_create_an_event()
    {
        $evento = TipoEvento::firstOrCreate(['tipo' => 'Curso'])->id;
        $random = (string) random_int(1, 365);
        $data_inicio = now()->addDays($random)->next('monday');
        $data_prazo = now()->addDays((int) $random + random_int(1,4));
        $response = $this->actingAs($this->currentUser())->post('/api/eventos', [
            'titulo' => 'Evento ' . $random . ' criado',
            'tipo_evento_id' => $evento,
            'user_id' => $this->currentUser()->id,
            'descricao' => 'Descrição de um Evento ' . $random  . ' muito completo',
            'data_inicio' => $data_inicio,
            'data_prazo' => $data_prazo,
            'data_conclusao' => null,
            'status' => 'aberto',
        ]);

//        $response->assertStatus(200);
        if ($response->status() === 200) {
            $this->assertDatabaseHas('eventos', [
                'titulo' => 'Evento ' . $random . ' criado'
            ]);
            return;
        }
        $response->assertStatus(202);
    }

    public function test_cannot_create_an_event_with_overlapping_dates()
    {
        $evento = Eventos::first();
        $data_inicio = $evento->data_inicio;
        $data_prazo = $evento->data_prazo;

        $tipo_evento = TipoEvento::firstOrCreate(['tipo' => 'Curso'])->id;
        $response = $this->actingAs($this->currentUser())->post('/api/eventos', [
            'titulo' => 'Evento Por Cima de Outro Evento...',
            'tipo_evento_id' => $tipo_evento,
            'user_id' => 1,
            'descricao' => 'Descrição de um Evento muito completo, por Cima de Outro Evento...',
            'data_inicio' => $data_inicio,
            'data_prazo' => $data_prazo,
            'data_conclusao' => null,
            'status' => 'aberto',
        ]);

        $response->assertJson(['message' => 'Evento não cadastrado, existem outros eventos nas datas requeridas!']);
        $response->assertStatus(202);

        $this->assertDatabaseMissing('eventos', [
            'titulo' => 'Evento Por Cima de Outro Evento...',
        ]);
    }

    public function test_cannot_create_an_event_on_weekends()
    {
        $evento = TipoEvento::firstOrCreate(['tipo' => 'Curso'])->id;
        $response = $this->actingAs($this->currentUser())->post('/api/eventos', [
            'titulo' => 'Evento no fim de semana...',
            'tipo_evento_id' => $evento,
            'user_id' => 1,
            'descricao' => 'Descrição de um Eventono fim de semana...',
            'data_inicio' => now()->next('saturday'),
            'data_prazo' => now()->next('sunday'),
            'data_conclusao' => null,
            'status' => 'aberto',
        ]);

        $response->assertJson(['message' => 'Evento não cadastrado, data somente dísponivel em dias de semana!']);
        $response->assertStatus(202);

        $this->assertDatabaseMissing('eventos', [
            'titulo' => 'Evento no fim de semana...',
            'descricao' => 'Descrição de um Eventono fim de semana...',
        ]);
    }

    public function test_can_return_some_event()
    {
        $evento = Eventos::latest()->first();

        $response = $this->actingAs($this->currentUser())->get('/api/eventos/' . $evento->id);

        $response->assertOk();
        $response->assertJsonFragment(['titulo' => $evento->titulo]);
    }

    public function test_can_filter_based_on_data_inicio()
    {
        $data_inicio = now()->toDate();
        $response = $this->actingAs($this->currentUser())
            ->get(route('eventos.index', ['data_inicio' => $data_inicio]));

        $response->assertJsonIsArray();
        $response->assertStatus(200);
    }

    public function test_can_filter_based_on_data_prazo()
    {
        $data_prazo = now()->toDate();
        $response = $this->actingAs($this->currentUser())
            ->get(route('eventos.index', ['data_prazo' => $data_prazo]));

        $response->assertJsonIsArray();
        $response->assertStatus(200);
    }

    public function test_can_filter_based_on_data_conclusao()
    {
        $data_conclusao = now()->toDate();
        $response = $this->actingAs($this->currentUser())
            ->get(route('eventos.index', ['data_conclusao' => $data_conclusao]));

        $response->assertJsonIsArray();
        $response->assertStatus(200);
    }

    public function test_can_update_some_event()
    {
        $eventos = Eventos::latest()->first();
        $response = $this->actingAs($this->currentUser())
            ->put(route('eventos.update', ['evento' => $eventos->id]), [
                'titulo' => 'Evento atualizado ' . (string) random_int(1, 9912),
                'descricao' => 'Evento atualizado com a descricao........'
            ]);

        $response->assertStatus(200);
    }

}
